//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
// @ts-nocheck

export class AuthApiBase {
  authToken = "";
  protected constructor() {}

  // Enforce always return empty string as baseUrl
  getBaseUrl(defaultUrl: string, baseUrl: string) {
    return "";
  }

  setAuthToken(token: string) {
    this.authToken = token;
  }

  protected transformOptions(options: any): Promise<any> {
    if (this.authToken) {
      options.headers["authorization"] = `Bearer ${this.authToken}`;
    }
    return Promise.resolve(options);
  }
}

export class CustomerModuleClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get organizations
     * @return Success
     */
    listOrganizations(): Promise<Organization[]> {
        let url_ = this.baseUrl + "/api/members/organizations";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processListOrganizations(_response);
        });
    }

    protected processListOrganizations(response: Response): Promise<Organization[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Organization.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization[]>(null as any);
    }

    /**
     * Get members
     * @param body (optional) concrete instance of SearchCriteria type type will be created by using PolymorphicMemberSearchCriteriaJsonConverter
     * @return Success
     */
    searchMember(body?: MembersSearchCriteria | undefined): Promise<MemberSearchResult> {
        let url_ = this.baseUrl + "/api/members/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchMember(_response);
        });
    }

    protected processSearchMember(response: Response): Promise<MemberSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MemberSearchResult>(null as any);
    }

    /**
     * Get member
     * @param id member id
     * @param responseGroup (optional) response group
     * @param memberType (optional) member type
     * @return Success
     */
    getMemberById(id: string, responseGroup?: string | undefined, memberType?: string | undefined): Promise<Member> {
        let url_ = this.baseUrl + "/api/members/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (responseGroup === null)
            throw new Error("The parameter 'responseGroup' cannot be null.");
        else if (responseGroup !== undefined)
            url_ += "responseGroup=" + encodeURIComponent("" + responseGroup) + "&";
        if (memberType === null)
            throw new Error("The parameter 'memberType' cannot be null.");
        else if (memberType !== undefined)
            url_ += "memberType=" + encodeURIComponent("" + memberType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMemberById(_response);
        });
    }

    protected processGetMemberById(response: Response): Promise<Member> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Member.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Member>(null as any);
    }

    /**
     * @param responseGroup (optional) 
     * @param memberType (optional) 
     * @return Success
     */
    getMemberByUserId(userId: string, responseGroup?: string | undefined, memberType?: string | undefined): Promise<Member> {
        let url_ = this.baseUrl + "/api/members/accounts/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (responseGroup === null)
            throw new Error("The parameter 'responseGroup' cannot be null.");
        else if (responseGroup !== undefined)
            url_ += "responseGroup=" + encodeURIComponent("" + responseGroup) + "&";
        if (memberType === null)
            throw new Error("The parameter 'memberType' cannot be null.");
        else if (memberType !== undefined)
            url_ += "memberType=" + encodeURIComponent("" + memberType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMemberByUserId(_response);
        });
    }

    protected processGetMemberByUserId(response: Response): Promise<Member> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Member.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Member>(null as any);
    }

    /**
     * @param ids (optional) 
     * @param responseGroup (optional) 
     * @param memberTypes (optional) 
     * @return Success
     */
    getMembersByIds(ids?: string[] | undefined, responseGroup?: string | undefined, memberTypes?: string[] | undefined): Promise<Member[]> {
        let url_ = this.baseUrl + "/api/members?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (responseGroup === null)
            throw new Error("The parameter 'responseGroup' cannot be null.");
        else if (responseGroup !== undefined)
            url_ += "responseGroup=" + encodeURIComponent("" + responseGroup) + "&";
        if (memberTypes === null)
            throw new Error("The parameter 'memberTypes' cannot be null.");
        else if (memberTypes !== undefined)
            memberTypes && memberTypes.forEach(item => { url_ += "memberTypes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMembersByIds(_response);
        });
    }

    protected processGetMembersByIds(response: Response): Promise<Member[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Member.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Member[]>(null as any);
    }

    /**
     * Create new member (can be any object inherited from Member type)
     * @param body (optional) concrete instance of abstract member type will be created by using PolymorphicMemberJsonConverter
     * @return Success
     */
    createMember(body?: Member | undefined): Promise<Member> {
        let url_ = this.baseUrl + "/api/members";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateMember(_response);
        });
    }

    protected processCreateMember(response: Response): Promise<Member> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Member.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Member>(null as any);
    }

    /**
     * Update member
     * @param body (optional) concrete instance of abstract member type will be created by using PolymorphicMemberJsonConverter
     * @return No Content
     */
    updateMember(body?: Member | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/members";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMember(_response);
        });
    }

    protected processUpdateMember(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete members
     * @param ids (optional) An array of members ids
     * @return No Content
     */
    deleteMembers(ids?: string[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/members?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteMembers(_response);
        });
    }

    protected processDeleteMembers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Bulk create new members (can be any objects inherited from Member type)
     * @param body (optional) Array of concrete instances of abstract member type will be created by using PolymorphicMemberJsonConverter
     * @return Success
     */
    bulkCreateMembers(body?: Member[] | undefined): Promise<Member[]> {
        let url_ = this.baseUrl + "/api/members/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkCreateMembers(_response);
        });
    }

    protected processBulkCreateMembers(response: Response): Promise<Member[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Member.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Member[]>(null as any);
    }

    /**
     * Bulk update members
     * @param body (optional) Array of concrete instances of abstract member type will be created by using PolymorphicMemberJsonConverter
     * @return No Content
     */
    bulkUpdateMembers(body?: Member[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/members/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkUpdateMembers(_response);
        });
    }

    protected processBulkUpdateMembers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Bulk delete members
     * @param body (optional) concrete instance of SearchCriteria type will be created by using PolymorphicMemberSearchCriteriaJsonConverter
     * @return No Content
     */
    bulkDeleteMembersBySearchCriteria(body?: MembersSearchCriteria | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/members/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkDeleteMembersBySearchCriteria(_response);
        });
    }

    protected processBulkDeleteMembersBySearchCriteria(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create contact
     * @param body (optional) 
     * @return Success
     */
    createContact(body?: Contact | undefined): Promise<Contact> {
        let url_ = this.baseUrl + "/api/contacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateContact(_response);
        });
    }

    protected processCreateContact(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contact.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(null as any);
    }

    /**
     * Update contact
     * @param body (optional) 
     * @return No Content
     */
    updateContact(body?: Contact | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/contacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateContact(_response);
        });
    }

    protected processUpdateContact(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete contacts
     * @param ids (optional) An array of contacts ids
     * @return No Content
     */
    deleteContacts(ids?: string[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/contacts?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteContacts(_response);
        });
    }

    protected processDeleteContacts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get plenty contacts
     * @param ids (optional) contact IDs
     * @return Success
     */
    getContactsByIds(ids?: string[] | undefined): Promise<Contact[]> {
        let url_ = this.baseUrl + "/api/contacts?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetContactsByIds(_response);
        });
    }

    protected processGetContactsByIds(response: Response): Promise<Contact[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Contact.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact[]>(null as any);
    }

    /**
     * Bulk create contacts
     * @param body (optional) 
     * @return Success
     */
    bulkCreateContacts(body?: Contact[] | undefined): Promise<Contact[]> {
        let url_ = this.baseUrl + "/api/contacts/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkCreateContacts(_response);
        });
    }

    protected processBulkCreateContacts(response: Response): Promise<Contact[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Contact.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact[]>(null as any);
    }

    /**
     * Bulk update contact
     * @param body (optional) 
     * @return No Content
     */
    bulkUpdateContacts(body?: Contact[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/contacts/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkUpdateContacts(_response);
        });
    }

    protected processBulkUpdateContacts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create organization
     * @param body (optional) 
     * @return Success
     */
    createOrganization(body?: Organization | undefined): Promise<Organization> {
        let url_ = this.baseUrl + "/api/organizations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateOrganization(_response);
        });
    }

    protected processCreateOrganization(response: Response): Promise<Organization> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Organization.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization>(null as any);
    }

    /**
     * Update organization
     * @param body (optional) 
     * @return No Content
     */
    updateOrganization(body?: Organization | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/organizations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateOrganization(_response);
        });
    }

    protected processUpdateOrganization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete organizations
     * @param ids (optional) An array of organizations ids
     * @return No Content
     */
    deleteOrganizations(ids?: string[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/organizations?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteOrganizations(_response);
        });
    }

    protected processDeleteOrganizations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get plenty organizations
     * @param ids (optional) Organization ids
     * @return Success
     */
    getOrganizationsByIds(ids?: string[] | undefined): Promise<Organization[]> {
        let url_ = this.baseUrl + "/api/organizations?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetOrganizationsByIds(_response);
        });
    }

    protected processGetOrganizationsByIds(response: Response): Promise<Organization[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Organization.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization[]>(null as any);
    }

    /**
     * Bulk create organizations
     * @param body (optional) 
     * @return No Content
     */
    bulkCreateOrganizations(body?: Organization[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/organizations/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkCreateOrganizations(_response);
        });
    }

    protected processBulkCreateOrganizations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Bulk update organization
     * @param body (optional) 
     * @return No Content
     */
    bulkUpdateOrganizations(body?: Organization[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/organizations/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkUpdateOrganizations(_response);
        });
    }

    protected processBulkUpdateOrganizations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get organization
     * @param id Organization id
     * @return Success
     */
    getOrganizationById(id: string): Promise<Organization> {
        let url_ = this.baseUrl + "/api/organizations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetOrganizationById(_response);
        });
    }

    protected processGetOrganizationById(response: Response): Promise<Organization> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Organization.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization>(null as any);
    }

    /**
     * Search organizations
     * @param body (optional) concrete instance of SearchCriteria type type will be created by using PolymorphicMemberSearchCriteriaJsonConverter
     * @return Success
     */
    searchOrganizations(body?: MembersSearchCriteria | undefined): Promise<OrganizationSearchResult> {
        let url_ = this.baseUrl + "/api/organizations/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchOrganizations(_response);
        });
    }

    protected processSearchOrganizations(response: Response): Promise<OrganizationSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationSearchResult>(null as any);
    }

    /**
     * Get contact
     * @param id Contact ID
     * @return Success
     */
    getContactById(id: string): Promise<Contact> {
        let url_ = this.baseUrl + "/api/contacts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetContactById(_response);
        });
    }

    protected processGetContactById(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contact.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(null as any);
    }

    /**
     * Search contacts
     * @param body (optional) concrete instance of SearchCriteria type type will be created by using PolymorphicMemberSearchCriteriaJsonConverter
     * @return Success
     */
    searchContacts(body?: MembersSearchCriteria | undefined): Promise<ContactSearchResult> {
        let url_ = this.baseUrl + "/api/contacts/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchContacts(_response);
        });
    }

    protected processSearchContacts(response: Response): Promise<ContactSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactSearchResult>(null as any);
    }

    /**
     * Get vendor
     * @param id Vendor ID
     * @return Success
     */
    getVendorById(id: string): Promise<Vendor> {
        let url_ = this.baseUrl + "/api/vendors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetVendorById(_response);
        });
    }

    protected processGetVendorById(response: Response): Promise<Vendor> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Vendor.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Vendor>(null as any);
    }

    /**
     * Get plenty vendors
     * @param ids (optional) Vendors IDs
     * @return Success
     */
    getVendorsByIds(ids?: string[] | undefined): Promise<Vendor[]> {
        let url_ = this.baseUrl + "/api/vendors?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetVendorsByIds(_response);
        });
    }

    protected processGetVendorsByIds(response: Response): Promise<Vendor[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Vendor.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Vendor[]>(null as any);
    }

    /**
     * Search vendors
     * @param body (optional) concrete instance of SearchCriteria type type will be created by using PolymorphicMemberSearchCriteriaJsonConverter
     * @return Success
     */
    searchVendors(body?: MembersSearchCriteria | undefined): Promise<VendorSearchResult> {
        let url_ = this.baseUrl + "/api/vendors/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchVendors(_response);
        });
    }

    protected processSearchVendors(response: Response): Promise<VendorSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VendorSearchResult>(null as any);
    }

    /**
     * @param memberId (optional) 
     * @param body (optional) 
     * @return No Content
     */
    updateAddesses(memberId?: string | undefined, body?: CustomerAddress[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/addresses?";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateAddesses(_response);
        });
    }

    protected processUpdateAddesses(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create employee
     * @param body (optional) 
     * @return Success
     */
    createEmployee(body?: Employee | undefined): Promise<Employee> {
        let url_ = this.baseUrl + "/api/employees";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateEmployee(_response);
        });
    }

    protected processCreateEmployee(response: Response): Promise<Employee> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Employee.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Employee>(null as any);
    }

    /**
     * Get plenty employees
     * @param ids (optional) contact IDs
     * @return Success
     */
    getEmployeesByIds(ids?: string[] | undefined): Promise<Employee[]> {
        let url_ = this.baseUrl + "/api/employees?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEmployeesByIds(_response);
        });
    }

    protected processGetEmployeesByIds(response: Response): Promise<Employee[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Employee.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Employee[]>(null as any);
    }

    /**
     * Create employee
     * @param body (optional) 
     * @return Success
     */
    bulkCreateEmployees(body?: Employee[] | undefined): Promise<Employee[]> {
        let url_ = this.baseUrl + "/api/employees/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkCreateEmployees(_response);
        });
    }

    protected processBulkCreateEmployees(response: Response): Promise<Employee[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Employee.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Employee[]>(null as any);
    }

    /**
     * Get all member organizations
     * @param id member Id
     * @return Success
     */
    getMemberOrganizations(id: string): Promise<Organization[]> {
        let url_ = this.baseUrl + "/api/members/{id}/organizations";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMemberOrganizations(_response);
        });
    }

    protected processGetMemberOrganizations(response: Response): Promise<Organization[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Organization.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization[]>(null as any);
    }
}

/** Obsolete. Left due to compatibility issues. Will be removed. Instead of, use: ApplicationUser.EmailConfirmed, ApplicationUser.LockoutEnd. */
export enum AccountState {
    PendingApproval = "PendingApproval",
    Approved = "Approved",
    Rejected = "Rejected",
}

export enum AddressType {
    Undefined = "Undefined",
    Billing = "Billing",
    Shipping = "Shipping",
    BillingAndShipping = "BillingAndShipping",
    Pickup = "Pickup",
}

export class ApplicationUser implements IApplicationUser {
    /** Tenant id */
    storeId?: string | undefined;
    memberId?: string | undefined;
    isAdministrator?: boolean;
    photoUrl?: string | undefined;
    userType?: string | undefined;
    status?: string | undefined;
    password?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    roles?: Role[] | undefined;
    /** Obsolete. Use LockoutEnd. DateTime in UTC when lockout ends, any time in the past is considered not locked out. */
    lockoutEndDateUtc?: Date | undefined;
    /** Obsolete. Left due to compatibility issues. Will be removed. Instead of, use: ApplicationUser.EmailConfirmed, ApplicationUser.LockoutEnd. */
    userState?: ApplicationUserUserState;
    /** Obsolete. All permissions from assigned roles. */
    permissions?: string[] | undefined;
    /** External provider logins. */
    logins?: ApplicationUserLogin[] | undefined;
    /** Indicates that the password for this user is expired and must be changed. */
    passwordExpired?: boolean;
    /** The last date when the password was changed */
    lastPasswordChangedDate?: Date | undefined;
    /** The last date when the requested password change. */
    lastPasswordChangeRequestDate?: Date | undefined;
    /** The last login date */
    lastLoginDate?: Date | undefined;
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;

    constructor(data?: IApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.memberId = _data["memberId"];
            this.isAdministrator = _data["isAdministrator"];
            this.photoUrl = _data["photoUrl"];
            this.userType = _data["userType"];
            this.status = _data["status"];
            this.password = _data["password"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(Role.fromJS(item));
            }
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? new Date(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.userState = _data["userState"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins!.push(ApplicationUserLogin.fromJS(item));
            }
            this.passwordExpired = _data["passwordExpired"];
            this.lastPasswordChangedDate = _data["lastPasswordChangedDate"] ? new Date(_data["lastPasswordChangedDate"].toString()) : <any>undefined;
            this.lastPasswordChangeRequestDate = _data["lastPasswordChangeRequestDate"] ? new Date(_data["lastPasswordChangeRequestDate"].toString()) : <any>undefined;
            this.lastLoginDate = _data["lastLoginDate"] ? new Date(_data["lastLoginDate"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["memberId"] = this.memberId;
        data["isAdministrator"] = this.isAdministrator;
        data["photoUrl"] = this.photoUrl;
        data["userType"] = this.userType;
        data["status"] = this.status;
        data["password"] = this.password;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["userState"] = this.userState;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        data["passwordExpired"] = this.passwordExpired;
        data["lastPasswordChangedDate"] = this.lastPasswordChangedDate ? this.lastPasswordChangedDate.toISOString() : <any>undefined;
        data["lastPasswordChangeRequestDate"] = this.lastPasswordChangeRequestDate ? this.lastPasswordChangeRequestDate.toISOString() : <any>undefined;
        data["lastLoginDate"] = this.lastLoginDate ? this.lastLoginDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data;
    }
}

export interface IApplicationUser {
    /** Tenant id */
    storeId?: string | undefined;
    memberId?: string | undefined;
    isAdministrator?: boolean;
    photoUrl?: string | undefined;
    userType?: string | undefined;
    status?: string | undefined;
    password?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    roles?: Role[] | undefined;
    /** Obsolete. Use LockoutEnd. DateTime in UTC when lockout ends, any time in the past is considered not locked out. */
    lockoutEndDateUtc?: Date | undefined;
    /** Obsolete. Left due to compatibility issues. Will be removed. Instead of, use: ApplicationUser.EmailConfirmed, ApplicationUser.LockoutEnd. */
    userState?: ApplicationUserUserState;
    /** Obsolete. All permissions from assigned roles. */
    permissions?: string[] | undefined;
    /** External provider logins. */
    logins?: ApplicationUserLogin[] | undefined;
    /** Indicates that the password for this user is expired and must be changed. */
    passwordExpired?: boolean;
    /** The last date when the password was changed */
    lastPasswordChangedDate?: Date | undefined;
    /** The last date when the requested password change. */
    lastPasswordChangeRequestDate?: Date | undefined;
    /** The last login date */
    lastLoginDate?: Date | undefined;
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
}

export class ApplicationUserLogin implements IApplicationUserLogin {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;

    constructor(data?: IApplicationUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
        }
    }

    static fromJS(data: any): ApplicationUserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        return data;
    }
}

export interface IApplicationUserLogin {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
}

export class Contact implements IContact {
    salutation?: string | undefined;
    fullName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    birthDate?: Date | undefined;
    defaultLanguage?: string | undefined;
    timeZone?: string | undefined;
    organizations?: string[] | undefined;
    associatedOrganizations?: string[] | undefined;
    taxPayerId?: string | undefined;
    preferredDelivery?: string | undefined;
    preferredCommunication?: string | undefined;
    defaultShippingAddressId?: string | undefined;
    defaultBillingAddressId?: string | undefined;
    photoUrl?: string | undefined;
    isAnonymized?: boolean;
    about?: string | undefined;
    readonly objectType?: string | undefined;
    securityAccounts?: ApplicationUser[] | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    iconUrl?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salutation = _data["salutation"];
            this.fullName = _data["fullName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.defaultLanguage = _data["defaultLanguage"];
            this.timeZone = _data["timeZone"];
            if (Array.isArray(_data["organizations"])) {
                this.organizations = [] as any;
                for (let item of _data["organizations"])
                    this.organizations!.push(item);
            }
            if (Array.isArray(_data["associatedOrganizations"])) {
                this.associatedOrganizations = [] as any;
                for (let item of _data["associatedOrganizations"])
                    this.associatedOrganizations!.push(item);
            }
            this.taxPayerId = _data["taxPayerId"];
            this.preferredDelivery = _data["preferredDelivery"];
            this.preferredCommunication = _data["preferredCommunication"];
            this.defaultShippingAddressId = _data["defaultShippingAddressId"];
            this.defaultBillingAddressId = _data["defaultBillingAddressId"];
            this.photoUrl = _data["photoUrl"];
            this.isAnonymized = _data["isAnonymized"];
            this.about = _data["about"];
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["securityAccounts"])) {
                this.securityAccounts = [] as any;
                for (let item of _data["securityAccounts"])
                    this.securityAccounts!.push(ApplicationUser.fromJS(item));
            }
            this.name = _data["name"];
            this.memberType = _data["memberType"];
            this.outerId = _data["outerId"];
            this.status = _data["status"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CustomerAddress.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(item);
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(Note.fromJS(item));
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            this.iconUrl = _data["iconUrl"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salutation"] = this.salutation;
        data["fullName"] = this.fullName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["defaultLanguage"] = this.defaultLanguage;
        data["timeZone"] = this.timeZone;
        if (Array.isArray(this.organizations)) {
            data["organizations"] = [];
            for (let item of this.organizations)
                data["organizations"].push(item);
        }
        if (Array.isArray(this.associatedOrganizations)) {
            data["associatedOrganizations"] = [];
            for (let item of this.associatedOrganizations)
                data["associatedOrganizations"].push(item);
        }
        data["taxPayerId"] = this.taxPayerId;
        data["preferredDelivery"] = this.preferredDelivery;
        data["preferredCommunication"] = this.preferredCommunication;
        data["defaultShippingAddressId"] = this.defaultShippingAddressId;
        data["defaultBillingAddressId"] = this.defaultBillingAddressId;
        data["photoUrl"] = this.photoUrl;
        data["isAnonymized"] = this.isAnonymized;
        data["about"] = this.about;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.securityAccounts)) {
            data["securityAccounts"] = [];
            for (let item of this.securityAccounts)
                data["securityAccounts"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["memberType"] = this.memberType;
        data["outerId"] = this.outerId;
        data["status"] = this.status;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item);
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        data["iconUrl"] = this.iconUrl;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IContact {
    salutation?: string | undefined;
    fullName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    birthDate?: Date | undefined;
    defaultLanguage?: string | undefined;
    timeZone?: string | undefined;
    organizations?: string[] | undefined;
    associatedOrganizations?: string[] | undefined;
    taxPayerId?: string | undefined;
    preferredDelivery?: string | undefined;
    preferredCommunication?: string | undefined;
    defaultShippingAddressId?: string | undefined;
    defaultBillingAddressId?: string | undefined;
    photoUrl?: string | undefined;
    isAnonymized?: boolean;
    about?: string | undefined;
    objectType?: string | undefined;
    securityAccounts?: ApplicationUser[] | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    iconUrl?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ContactSearchResult implements IContactSearchResult {
    totalCount?: number;
    results?: Contact[] | undefined;

    constructor(data?: IContactSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Contact.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContactSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContactSearchResult {
    totalCount?: number;
    results?: Contact[] | undefined;
}

export class CustomerAddress implements ICustomerAddress {
    addressType?: CustomerAddressAddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    outerId?: string | undefined;
    isDefault?: boolean;
    description?: string | undefined;

    constructor(data?: ICustomerAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressType = _data["addressType"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.organization = _data["organization"];
            this.countryCode = _data["countryCode"];
            this.countryName = _data["countryName"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.zip = _data["zip"];
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.regionId = _data["regionId"];
            this.regionName = _data["regionName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.outerId = _data["outerId"];
            this.isDefault = _data["isDefault"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CustomerAddress {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressType"] = this.addressType;
        data["key"] = this.key;
        data["name"] = this.name;
        data["organization"] = this.organization;
        data["countryCode"] = this.countryCode;
        data["countryName"] = this.countryName;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["zip"] = this.zip;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["regionId"] = this.regionId;
        data["regionName"] = this.regionName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["outerId"] = this.outerId;
        data["isDefault"] = this.isDefault;
        data["description"] = this.description;
        return data;
    }
}

export interface ICustomerAddress {
    addressType?: CustomerAddressAddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    outerId?: string | undefined;
    isDefault?: boolean;
    description?: string | undefined;
}

export class DynamicObjectProperty implements IDynamicObjectProperty {
    objectId?: string | undefined;
    values?: DynamicPropertyObjectValue[] | undefined;
    name?: string | undefined;
    /** dynamic property description */
    description?: string | undefined;
    objectType?: string | undefined;
    /** Defines whether a property supports multiple values. */
    isArray?: boolean;
    /** Dictionary has a predefined set of values. User can select one or more of them and cannot enter arbitrary values. */
    isDictionary?: boolean;
    /** For multilingual properties user can enter different values for each of registered languages. */
    isMultilingual?: boolean;
    isRequired?: boolean;
    displayOrder?: number | undefined;
    /** The storage property type */
    valueType?: DynamicObjectPropertyValueType;
    /** Property names for different languages. */
    displayNames?: DynamicPropertyName[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicObjectProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectId = _data["objectId"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(DynamicPropertyObjectValue.fromJS(item));
            }
            this.name = _data["name"];
            this.description = _data["description"];
            this.objectType = _data["objectType"];
            this.isArray = _data["isArray"];
            this.isDictionary = _data["isDictionary"];
            this.isMultilingual = _data["isMultilingual"];
            this.isRequired = _data["isRequired"];
            this.displayOrder = _data["displayOrder"];
            this.valueType = _data["valueType"];
            if (Array.isArray(_data["displayNames"])) {
                this.displayNames = [] as any;
                for (let item of _data["displayNames"])
                    this.displayNames!.push(DynamicPropertyName.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicObjectProperty {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicObjectProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectId"] = this.objectId;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["description"] = this.description;
        data["objectType"] = this.objectType;
        data["isArray"] = this.isArray;
        data["isDictionary"] = this.isDictionary;
        data["isMultilingual"] = this.isMultilingual;
        data["isRequired"] = this.isRequired;
        data["displayOrder"] = this.displayOrder;
        data["valueType"] = this.valueType;
        if (Array.isArray(this.displayNames)) {
            data["displayNames"] = [];
            for (let item of this.displayNames)
                data["displayNames"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicObjectProperty {
    objectId?: string | undefined;
    values?: DynamicPropertyObjectValue[] | undefined;
    name?: string | undefined;
    /** dynamic property description */
    description?: string | undefined;
    objectType?: string | undefined;
    /** Defines whether a property supports multiple values. */
    isArray?: boolean;
    /** Dictionary has a predefined set of values. User can select one or more of them and cannot enter arbitrary values. */
    isDictionary?: boolean;
    /** For multilingual properties user can enter different values for each of registered languages. */
    isMultilingual?: boolean;
    isRequired?: boolean;
    displayOrder?: number | undefined;
    /** The storage property type */
    valueType?: DynamicObjectPropertyValueType;
    /** Property names for different languages. */
    displayNames?: DynamicPropertyName[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicPropertyName implements IDynamicPropertyName {
    /** Language ID, e.g. en-US. */
    locale?: string | undefined;
    name?: string | undefined;

    constructor(data?: IDynamicPropertyName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locale = _data["locale"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DynamicPropertyName {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locale"] = this.locale;
        data["name"] = this.name;
        return data;
    }
}

export interface IDynamicPropertyName {
    /** Language ID, e.g. en-US. */
    locale?: string | undefined;
    name?: string | undefined;
}

export class DynamicPropertyObjectValue implements IDynamicPropertyObjectValue {
    objectType?: string | undefined;
    objectId?: string | undefined;
    locale?: string | undefined;
    value?: any | undefined;
    valueId?: string | undefined;
    valueType?: DynamicPropertyObjectValueValueType;
    propertyId?: string | undefined;
    propertyName?: string | undefined;

    constructor(data?: IDynamicPropertyObjectValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectType = _data["objectType"];
            this.objectId = _data["objectId"];
            this.locale = _data["locale"];
            this.value = _data["value"];
            this.valueId = _data["valueId"];
            this.valueType = _data["valueType"];
            this.propertyId = _data["propertyId"];
            this.propertyName = _data["propertyName"];
        }
    }

    static fromJS(data: any): DynamicPropertyObjectValue {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyObjectValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectType"] = this.objectType;
        data["objectId"] = this.objectId;
        data["locale"] = this.locale;
        data["value"] = this.value;
        data["valueId"] = this.valueId;
        data["valueType"] = this.valueType;
        data["propertyId"] = this.propertyId;
        data["propertyName"] = this.propertyName;
        return data;
    }
}

export interface IDynamicPropertyObjectValue {
    objectType?: string | undefined;
    objectId?: string | undefined;
    locale?: string | undefined;
    value?: any | undefined;
    valueId?: string | undefined;
    valueType?: DynamicPropertyObjectValueValueType;
    propertyId?: string | undefined;
    propertyName?: string | undefined;
}

export enum DynamicPropertyValueType {
    Undefined = "Undefined",
    ShortText = "ShortText",
    LongText = "LongText",
    Integer = "Integer",
    Decimal = "Decimal",
    DateTime = "DateTime",
    Boolean = "Boolean",
    Html = "Html",
    Image = "Image",
}

export class Employee implements IEmployee {
    salutation?: string | undefined;
    fullName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    birthDate?: Date | undefined;
    defaultLanguage?: string | undefined;
    timeZone?: string | undefined;
    organizations?: string[] | undefined;
    employeeType?: string | undefined;
    isActive?: boolean;
    photoUrl?: string | undefined;
    readonly objectType?: string | undefined;
    securityAccounts?: ApplicationUser[] | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    iconUrl?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IEmployee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salutation = _data["salutation"];
            this.fullName = _data["fullName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.defaultLanguage = _data["defaultLanguage"];
            this.timeZone = _data["timeZone"];
            if (Array.isArray(_data["organizations"])) {
                this.organizations = [] as any;
                for (let item of _data["organizations"])
                    this.organizations!.push(item);
            }
            this.employeeType = _data["employeeType"];
            this.isActive = _data["isActive"];
            this.photoUrl = _data["photoUrl"];
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["securityAccounts"])) {
                this.securityAccounts = [] as any;
                for (let item of _data["securityAccounts"])
                    this.securityAccounts!.push(ApplicationUser.fromJS(item));
            }
            this.name = _data["name"];
            this.memberType = _data["memberType"];
            this.outerId = _data["outerId"];
            this.status = _data["status"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CustomerAddress.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(item);
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(Note.fromJS(item));
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            this.iconUrl = _data["iconUrl"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Employee {
        data = typeof data === 'object' ? data : {};
        let result = new Employee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salutation"] = this.salutation;
        data["fullName"] = this.fullName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["defaultLanguage"] = this.defaultLanguage;
        data["timeZone"] = this.timeZone;
        if (Array.isArray(this.organizations)) {
            data["organizations"] = [];
            for (let item of this.organizations)
                data["organizations"].push(item);
        }
        data["employeeType"] = this.employeeType;
        data["isActive"] = this.isActive;
        data["photoUrl"] = this.photoUrl;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.securityAccounts)) {
            data["securityAccounts"] = [];
            for (let item of this.securityAccounts)
                data["securityAccounts"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["memberType"] = this.memberType;
        data["outerId"] = this.outerId;
        data["status"] = this.status;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item);
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        data["iconUrl"] = this.iconUrl;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IEmployee {
    salutation?: string | undefined;
    fullName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    birthDate?: Date | undefined;
    defaultLanguage?: string | undefined;
    timeZone?: string | undefined;
    organizations?: string[] | undefined;
    employeeType?: string | undefined;
    isActive?: boolean;
    photoUrl?: string | undefined;
    objectType?: string | undefined;
    securityAccounts?: ApplicationUser[] | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    iconUrl?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Member implements IMember {
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    iconUrl?: string | undefined;
    readonly objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.memberType = _data["memberType"];
            this.outerId = _data["outerId"];
            this.status = _data["status"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CustomerAddress.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(item);
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(Note.fromJS(item));
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            this.iconUrl = _data["iconUrl"];
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Member {
        data = typeof data === 'object' ? data : {};
        let result = new Member();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["memberType"] = this.memberType;
        data["outerId"] = this.outerId;
        data["status"] = this.status;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item);
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        data["iconUrl"] = this.iconUrl;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IMember {
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    iconUrl?: string | undefined;
    objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class MemberSearchResult implements IMemberSearchResult {
    totalCount?: number;
    results?: Member[] | undefined;

    constructor(data?: IMemberSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Member.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MemberSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new MemberSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMemberSearchResult {
    totalCount?: number;
    results?: Member[] | undefined;
}

export class MembersSearchCriteria implements IMembersSearchCriteria {
    memberType?: string | undefined;
    memberTypes?: string[] | undefined;
    group?: string | undefined;
    groups?: string[] | undefined;
    memberId?: string | undefined;
    deepSearch?: boolean;
    outerIds?: string[] | undefined;
    responseGroup?: string | undefined;
    /** Search object type */
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    /** Search phrase */
    keyword?: string | undefined;
    /** Property is left for backward compatibility */
    searchPhrase?: string | undefined;
    /** Search phrase language */
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IMembersSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            if (Array.isArray(_data["memberTypes"])) {
                this.memberTypes = [] as any;
                for (let item of _data["memberTypes"])
                    this.memberTypes!.push(item);
            }
            this.group = _data["group"];
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            this.memberId = _data["memberId"];
            this.deepSearch = _data["deepSearch"];
            if (Array.isArray(_data["outerIds"])) {
                this.outerIds = [] as any;
                for (let item of _data["outerIds"])
                    this.outerIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): MembersSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new MembersSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        if (Array.isArray(this.memberTypes)) {
            data["memberTypes"] = [];
            for (let item of this.memberTypes)
                data["memberTypes"].push(item);
        }
        data["group"] = this.group;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        data["memberId"] = this.memberId;
        data["deepSearch"] = this.deepSearch;
        if (Array.isArray(this.outerIds)) {
            data["outerIds"] = [];
            for (let item of this.outerIds)
                data["outerIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IMembersSearchCriteria {
    memberType?: string | undefined;
    memberTypes?: string[] | undefined;
    group?: string | undefined;
    groups?: string[] | undefined;
    memberId?: string | undefined;
    deepSearch?: boolean;
    outerIds?: string[] | undefined;
    responseGroup?: string | undefined;
    /** Search object type */
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    /** Search phrase */
    keyword?: string | undefined;
    /** Property is left for backward compatibility */
    searchPhrase?: string | undefined;
    /** Search phrase language */
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class Note implements INote {
    title?: string | undefined;
    body?: string | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: INote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.body = _data["body"];
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Note {
        data = typeof data === 'object' ? data : {};
        let result = new Note();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["body"] = this.body;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface INote {
    title?: string | undefined;
    body?: string | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Organization implements IOrganization {
    description?: string | undefined;
    businessCategory?: string | undefined;
    ownerId?: string | undefined;
    parentId?: string | undefined;
    readonly objectType?: string | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    iconUrl?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IOrganization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.businessCategory = _data["businessCategory"];
            this.ownerId = _data["ownerId"];
            this.parentId = _data["parentId"];
            (<any>this).objectType = _data["objectType"];
            this.name = _data["name"];
            this.memberType = _data["memberType"];
            this.outerId = _data["outerId"];
            this.status = _data["status"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CustomerAddress.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(item);
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(Note.fromJS(item));
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            this.iconUrl = _data["iconUrl"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Organization {
        data = typeof data === 'object' ? data : {};
        let result = new Organization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["businessCategory"] = this.businessCategory;
        data["ownerId"] = this.ownerId;
        data["parentId"] = this.parentId;
        data["objectType"] = this.objectType;
        data["name"] = this.name;
        data["memberType"] = this.memberType;
        data["outerId"] = this.outerId;
        data["status"] = this.status;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item);
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        data["iconUrl"] = this.iconUrl;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganization {
    description?: string | undefined;
    businessCategory?: string | undefined;
    ownerId?: string | undefined;
    parentId?: string | undefined;
    objectType?: string | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    iconUrl?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class OrganizationSearchResult implements IOrganizationSearchResult {
    totalCount?: number;
    results?: Organization[] | undefined;

    constructor(data?: IOrganizationSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Organization.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrganizationSearchResult {
    totalCount?: number;
    results?: Organization[] | undefined;
}

export class Permission implements IPermission {
    id?: string | undefined;
    name?: string | undefined;
    /** Id of the module which has registered this permission. */
    moduleId?: string | undefined;
    /** Display name of the group to which this permission belongs. The '|' character is used to separate Child and parent groups. */
    groupName?: string | undefined;
    assignedScopes?: PermissionScope[] | undefined;
    readonly availableScopes?: PermissionScope[] | undefined;

    constructor(data?: IPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.moduleId = _data["moduleId"];
            this.groupName = _data["groupName"];
            if (Array.isArray(_data["assignedScopes"])) {
                this.assignedScopes = [] as any;
                for (let item of _data["assignedScopes"])
                    this.assignedScopes!.push(PermissionScope.fromJS(item));
            }
            if (Array.isArray(_data["availableScopes"])) {
                (<any>this).availableScopes = [] as any;
                for (let item of _data["availableScopes"])
                    (<any>this).availableScopes!.push(PermissionScope.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Permission {
        data = typeof data === 'object' ? data : {};
        let result = new Permission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["moduleId"] = this.moduleId;
        data["groupName"] = this.groupName;
        if (Array.isArray(this.assignedScopes)) {
            data["assignedScopes"] = [];
            for (let item of this.assignedScopes)
                data["assignedScopes"].push(item.toJSON());
        }
        if (Array.isArray(this.availableScopes)) {
            data["availableScopes"] = [];
            for (let item of this.availableScopes)
                data["availableScopes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermission {
    id?: string | undefined;
    name?: string | undefined;
    /** Id of the module which has registered this permission. */
    moduleId?: string | undefined;
    /** Display name of the group to which this permission belongs. The '|' character is used to separate Child and parent groups. */
    groupName?: string | undefined;
    assignedScopes?: PermissionScope[] | undefined;
    availableScopes?: PermissionScope[] | undefined;
}

export class PermissionScope implements IPermissionScope {
    /** Scope type name */
    type?: string | undefined;
    /** Display label for particular scope value used only for  representation */
    label?: string | undefined;
    /** Represent string scope value */
    scope?: string | undefined;

    constructor(data?: IPermissionScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.label = _data["label"];
            this.scope = _data["scope"];
        }
    }

    static fromJS(data: any): PermissionScope {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["label"] = this.label;
        data["scope"] = this.scope;
        return data;
    }
}

export interface IPermissionScope {
    /** Scope type name */
    type?: string | undefined;
    /** Display label for particular scope value used only for  representation */
    label?: string | undefined;
    /** Represent string scope value */
    scope?: string | undefined;
}

export class Role implements IRole {
    description?: string | undefined;
    permissions?: Permission[] | undefined;
    id?: string | undefined;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(Permission.fromJS(item));
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.normalizedName = _data["normalizedName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IRole {
    description?: string | undefined;
    permissions?: Permission[] | undefined;
    id?: string | undefined;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class SeoInfo implements ISeoInfo {
    name?: string | undefined;
    /** Slug */
    semanticUrl?: string | undefined;
    /** head title tag content */
    pageTitle?: string | undefined;
    /** <meta name="description" /> */
    metaDescription?: string | undefined;
    imageAltDescription?: string | undefined;
    /** <meta name="keywords" /> */
    metaKeywords?: string | undefined;
    /** Tenant StoreId which SEO defined */
    storeId?: string | undefined;
    /** SEO related object id */
    objectId?: string | undefined;
    /** SEO related object type name */
    objectType?: string | undefined;
    /** Active/Inactive */
    isActive?: boolean;
    languageCode?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ISeoInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.semanticUrl = _data["semanticUrl"];
            this.pageTitle = _data["pageTitle"];
            this.metaDescription = _data["metaDescription"];
            this.imageAltDescription = _data["imageAltDescription"];
            this.metaKeywords = _data["metaKeywords"];
            this.storeId = _data["storeId"];
            this.objectId = _data["objectId"];
            this.objectType = _data["objectType"];
            this.isActive = _data["isActive"];
            this.languageCode = _data["languageCode"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SeoInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SeoInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["semanticUrl"] = this.semanticUrl;
        data["pageTitle"] = this.pageTitle;
        data["metaDescription"] = this.metaDescription;
        data["imageAltDescription"] = this.imageAltDescription;
        data["metaKeywords"] = this.metaKeywords;
        data["storeId"] = this.storeId;
        data["objectId"] = this.objectId;
        data["objectType"] = this.objectType;
        data["isActive"] = this.isActive;
        data["languageCode"] = this.languageCode;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ISeoInfo {
    name?: string | undefined;
    /** Slug */
    semanticUrl?: string | undefined;
    /** head title tag content */
    pageTitle?: string | undefined;
    /** <meta name="description" /> */
    metaDescription?: string | undefined;
    imageAltDescription?: string | undefined;
    /** <meta name="keywords" /> */
    metaKeywords?: string | undefined;
    /** Tenant StoreId which SEO defined */
    storeId?: string | undefined;
    /** SEO related object id */
    objectId?: string | undefined;
    /** SEO related object type name */
    objectType?: string | undefined;
    /** Active/Inactive */
    isActive?: boolean;
    languageCode?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export enum SortDirection {
    Ascending = "Ascending",
    Descending = "Descending",
}

export class SortInfo implements ISortInfo {
    sortColumn?: string | undefined;
    sortDirection?: SortInfoSortDirection;

    constructor(data?: ISortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sortColumn = _data["sortColumn"];
            this.sortDirection = _data["sortDirection"];
        }
    }

    static fromJS(data: any): SortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sortColumn"] = this.sortColumn;
        data["sortDirection"] = this.sortDirection;
        return data;
    }
}

export interface ISortInfo {
    sortColumn?: string | undefined;
    sortDirection?: SortInfoSortDirection;
}

export class StringIdentityUserRole implements IStringIdentityUserRole {
    userId?: string | undefined;
    roleId?: string | undefined;

    constructor(data?: IStringIdentityUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): StringIdentityUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new StringIdentityUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface IStringIdentityUserRole {
    userId?: string | undefined;
    roleId?: string | undefined;
}

export class Vendor implements IVendor {
    description?: string | undefined;
    siteUrl?: string | undefined;
    logoUrl?: string | undefined;
    groupName?: string | undefined;
    securityAccounts?: ApplicationUser[] | undefined;
    readonly objectType?: string | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    iconUrl?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IVendor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.siteUrl = _data["siteUrl"];
            this.logoUrl = _data["logoUrl"];
            this.groupName = _data["groupName"];
            if (Array.isArray(_data["securityAccounts"])) {
                this.securityAccounts = [] as any;
                for (let item of _data["securityAccounts"])
                    this.securityAccounts!.push(ApplicationUser.fromJS(item));
            }
            (<any>this).objectType = _data["objectType"];
            this.name = _data["name"];
            this.memberType = _data["memberType"];
            this.outerId = _data["outerId"];
            this.status = _data["status"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CustomerAddress.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(item);
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(Note.fromJS(item));
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            this.iconUrl = _data["iconUrl"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Vendor {
        data = typeof data === 'object' ? data : {};
        let result = new Vendor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["siteUrl"] = this.siteUrl;
        data["logoUrl"] = this.logoUrl;
        data["groupName"] = this.groupName;
        if (Array.isArray(this.securityAccounts)) {
            data["securityAccounts"] = [];
            for (let item of this.securityAccounts)
                data["securityAccounts"].push(item.toJSON());
        }
        data["objectType"] = this.objectType;
        data["name"] = this.name;
        data["memberType"] = this.memberType;
        data["outerId"] = this.outerId;
        data["status"] = this.status;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item);
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        data["iconUrl"] = this.iconUrl;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IVendor {
    description?: string | undefined;
    siteUrl?: string | undefined;
    logoUrl?: string | undefined;
    groupName?: string | undefined;
    securityAccounts?: ApplicationUser[] | undefined;
    objectType?: string | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    iconUrl?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class VendorSearchResult implements IVendorSearchResult {
    readonly vendors?: Vendor[] | undefined;
    totalCount?: number;
    results?: Vendor[] | undefined;

    constructor(data?: IVendorSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["vendors"])) {
                (<any>this).vendors = [] as any;
                for (let item of _data["vendors"])
                    (<any>this).vendors!.push(Vendor.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Vendor.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VendorSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new VendorSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.vendors)) {
            data["vendors"] = [];
            for (let item of this.vendors)
                data["vendors"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVendorSearchResult {
    vendors?: Vendor[] | undefined;
    totalCount?: number;
    results?: Vendor[] | undefined;
}

export enum ApplicationUserUserState {
    PendingApproval = "PendingApproval",
    Approved = "Approved",
    Rejected = "Rejected",
}

export enum CustomerAddressAddressType {
    Undefined = "Undefined",
    Billing = "Billing",
    Shipping = "Shipping",
    BillingAndShipping = "BillingAndShipping",
    Pickup = "Pickup",
}

export enum DynamicObjectPropertyValueType {
    Undefined = "Undefined",
    ShortText = "ShortText",
    LongText = "LongText",
    Integer = "Integer",
    Decimal = "Decimal",
    DateTime = "DateTime",
    Boolean = "Boolean",
    Html = "Html",
    Image = "Image",
}

export enum DynamicPropertyObjectValueValueType {
    Undefined = "Undefined",
    ShortText = "ShortText",
    LongText = "LongText",
    Integer = "Integer",
    Decimal = "Decimal",
    DateTime = "DateTime",
    Boolean = "Boolean",
    Html = "Html",
    Image = "Image",
}

export enum SortInfoSortDirection {
    Ascending = "Ascending",
    Descending = "Descending",
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

/* eslint-disable */